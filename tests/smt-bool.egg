; https://smt-lib.org/examples.shtml

; Basic Boolean example
; (set-option :print-success false)
; (set-logic QF_UF)
; (declare-const p Bool)
; (assert (and p (not p)))
; (check-sat) ; returns 'unsat'
; (exit)
(let p (smt-bool-const "p"))
(check (= false (smt-sat? (smt-solve (and p (not p))))))
(check (= true (smt-sat? (smt-solve (and p p)))))

; Integer arithmetic
; (set-logic QF_LIA)
; (declare-const x Int)
; (declare-const y Int)
; (assert (= (- x y) (+ x (- y) 1)))
; (check-sat)
; ; unsat
; (exit)
(let x (smt-int-const "x"))
(let y (smt-int-const "y"))
(check (= false (smt-sat? (smt-solve (smt-= x (+ x (smt-int 1)))))))

; Uninterpreted functions
; (declare-fun x (Int) Int)  (declare-fun y (Int) Int)
; (declare-fun t (Int) Int)
; (assert (= (t 0) (x 0)))
; (assert (= (y 1) (t 0)))
; (assert (= (x 1) (y 1)))

; (assert (not 
;   (and (= (x 1) (y 0)) 
;        (= (y 1) (x 0)))))
; (check-sat)
; (get-value ((x 0) (y 0) (x 1) (y 1)))
(let x_fun (smt-fn-int "x" "Int"))
(let t_fun (smt-fn-int "t" "Int"))
(let y_fun (smt-fn-int "y" "Int"))

(let false_cond1 (smt-= (smt-call x_fun (smt-int 0)) (smt-int 0)))
(let false_cond2 (smt-= (smt-call x_fun (smt-int 0)) (smt-int 1)))
(let uf_false_model (smt-solve false_cond1 false_cond2))
(check (= false (smt-sat? uf_false_model)))

(let cond1 (smt-= (smt-call x_fun (smt-int 0)) (smt-call t_fun (smt-int 0))))
(let cond2 (smt-= (smt-call y_fun (smt-int 1)) (smt-call t_fun (smt-int 0))))
(let cond3 (smt-= (smt-call x_fun (smt-int 1)) (smt-call y_fun (smt-int 1))))

(let cond4 (not (and (smt-= (smt-call x_fun (smt-int 1)) (smt-call y_fun (smt-int 0)))
            (smt-= (smt-call y_fun (smt-int 1)) (smt-call x_fun (smt-int 0))))))

(let f_model (smt-solve cond1 cond2 cond3 cond4))
(check (= true (smt-sat? f_model)))
(extract f_model)


; Getting values or models
; (set-option :print-success false)
; (set-option :produce-models true)
; (set-logic QF_LIA)
; (declare-const x Int)
; (declare-const y Int)
; (assert (= (+ x (* 2 y)) 20))
; (assert (= (- x y) 2))
; (check-sat)
; ; sat
; (get-value (x y))
; ; ((x 8) (y 6))
; (get-model)
; ; ((define-fun x () Int 8)
; ;  (define-fun y () Int 6)
; ; )
; (exit)

(let two (smt-int 2))
(let twenty (smt-int 20))
(let model (smt-solve (smt-= (+ x (* two y)) twenty)
        (smt-= (- x y) two)))
(extract model)
; (smt-model (smt-value "x" 8) (smt-value "y" 6))
(check (= true (smt-sat? model)))
(check (= 8 (smt-value model x)))
(check (= 6 (smt-value model y)))

;; verify that getting boolean values from model works
(let p_model (smt-solve p))
(check (= true (smt-sat? p_model)))
(check (= true (smt-value p_model p)))
