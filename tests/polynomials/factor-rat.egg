; Factor rewriting for polynomials with rational roots using SMT.

; A datatype for representing polynomials in a single variable over Q.
; We rewrite from the form ax^b+...+c to the form (x-a)^b*...*c.
; If any roots are non-rational (algebraic or complex), they are not rewritten.
(datatype Polynomial
  ; (Const a) := a
  (Const Rational)

  ; (AddTerm a b p) := ax^b + p
  (AddTerm Rational i64 Polynomial)

  ; (MulFactor a b p) := (x-a)^b * p
  (MulFactor Rational i64 Polynomial)

  ; Derivatives are used as backend values for the factoring analysis.
  (Deriv Polynomial :cost 999999)
  (NthDeriv i64 Polynomial :cost 999999))

; Find the coefficient and degree of the highest-degree term
(ruleset coeff-deg)
(function coefficient (Polynomial) Rational :merge new)
(function degree (Polynomial) i64 :merge new)
(rule
  ((Const a))
  ((set (coefficient (Const a)) a) (set (degree (Const a)) 0))
  :ruleset coeff-deg)
(rule
  ((AddTerm a b p) (= (coefficient p) c) (= (degree p) d) (< b d))
  ((set (degree (AddTerm a b p)) d) (set (coefficient (AddTerm a b p)) c))
  :ruleset coeff-deg)
(rule
  ((AddTerm a b p) (= (coefficient p) c) (= (degree p) d) (= b d))
  ((set (degree (AddTerm a b p)) d) (set (coefficient (AddTerm a b p)) (+ a c)))
  :ruleset coeff-deg)
(rule
  ((AddTerm a b p) (= (coefficient p) c) (= (degree p) d) (> b d))
  ((set (degree (AddTerm a b p)) b) (set (coefficient (AddTerm a b p)) a))
  :ruleset coeff-deg)

; Initialize an empty list of roots for polynomials tagged with factorable
(ruleset init-roots)
(function factorable (Polynomial) bool :merge new)
(function partial-factored (Polynomial) Polynomial :merge new)
(function num-roots (Polynomial) i64 :merge new)
(rule
  ((= (factorable p) true) (= (coefficient p) c))
  ((set (partial-factored p) (Const c)) (set (num-roots p) 0))
  :ruleset init-roots)

; Convert polynomials to an SMT form
(ruleset to-smt)
(let _p_ (smt-int-const "p"))
(let _q_ (smt-int-const "q"))
(let _x_ (/ (smt-int->real _p_) (smt-int->real _q_)))
(function smt-repr (Polynomial) SMTReal :merge new)
(rule
  ((Const a))
  ((set
      (smt-repr (Const a))
      (/
        (smt-int->real (smt-int (numer a)))
        (smt-int->real (smt-int (denom a))))))
  :ruleset to-smt)
(rule
  ((AddTerm a b p) (!= b 0) (= (smt-repr p) s))
  ((set
      (smt-repr (AddTerm a b p))
      (+
        (*
          (/
            (smt-int->real (smt-int (numer a)))
            (smt-int->real (smt-int (denom a))))
          (^ _x_ (smt-int->real (smt-int b))))
        s)))
  :ruleset to-smt)
(rule
  ((AddTerm a b p) (= b 0) (= (smt-repr p) s))
  ((set
      (smt-repr (AddTerm a b p))
      (+
        (/
          (smt-int->real (smt-int (numer a)))
          (smt-int->real (smt-int (denom a))))
        s)))
  :ruleset to-smt)

; Convert the current roots of polynomials tagged with factorable to constraints
(ruleset make-constraints)
(function constraints (Polynomial) SMTBool :merge new)
(rule
  ((Const a))
  ((set
      (constraints (Const a))
      (not (smt-= _q_ (smt-int 0)))))
  :ruleset make-constraints)
(rule
  ((MulFactor a b p) (= (constraints p) c))
  ((set
      (constraints (MulFactor a b p))
      (and
        (not (smt-= _x_ (/
              (smt-int->real (smt-int (numer a)))
              (smt-int->real (smt-int (denom a))))))
        c)))
  :ruleset make-constraints)

; Solve for the next rational root of polynomials tagged with factorable
(ruleset solve-root)
(function model (Polynomial) SMTSolved :merge new)
(rule
  (
    (= (factorable p) true)
    (= (num-roots p) n)
    (= (degree p) d)
    (< n d)
    (= (smt-repr p) s)
    (= (partial-factored p) f)
    (= (constraints f) c))
  ((set (model p) (smt-solve (and (smt-= s (smt-real 0.0)) c))))
  :ruleset solve-root)

; Update the partial factoring of polynomials tagged with factorable
; If we haven't found all the roots but no rational one can be found,
; mark the polynomial unfactorable (for this analysis)
(ruleset update-factors)
(rule
  (
    (= (factorable p) true)
    (= (num-roots p) n)
    (= (degree p) d)
    (< n d)
    (= (model p) m)
    (= (smt-sat? m) true)
    (= (partial-factored p) f))
  (
    (set
      (partial-factored p)
      (MulFactor (rational (smt-value m _p_) (smt-value m _q_)) 1 f))
    (set (num-roots p) (+ n 1))
    (union p (NthDeriv 0 p)))
  :ruleset update-factors)
(rule
  (
    (= (factorable p) true)
    (= (num-roots p) n)
    (= (degree p) d)
    (< n d)
    (= (model p) m)
    (= (smt-sat? m) false))
  ((set (factorable p) false))
  :ruleset update-factors)

; Add a derivative to the egraph to see if we can increase
; the multiplicity of a root
(ruleset add-deriv)
(rule
  (
    (= (factorable p) true)
    (= (partial-factored p) (MulFactor a b f))
    (NthDeriv (- b 1) p))
  ((union (Deriv (NthDeriv (- b 1) p)) (NthDeriv b p)))
  :ruleset add-deriv)

; Calculate derivatives of polynomials
(ruleset differentiate)
(rewrite (Deriv (Const a)) (Const (rational 0 1)) :ruleset differentiate)
(rewrite (Deriv (AddTerm a 0 p)) (Deriv p) :ruleset differentiate)
(rewrite
  (Deriv (AddTerm a b p))
  (AddTerm (rational (* b (numer a)) (denom a)) (- b 1) (Deriv p))
  :when ((> b 0))
  :ruleset differentiate)

; Increment multiplicity of most recently found roots
(ruleset incr-multiplicity)
(rule
  (
    (= (factorable p) true)
    (= (partial-factored p) (MulFactor a b f))
    (= (smt-repr (NthDeriv b p)) s)
    (= (smt-sat? (smt-solve (and
            (smt-= _p_ (smt-int (numer a)))
            (and
              (smt-= _q_ (smt-int (denom a)))
              (smt-= s (smt-real 0.0))
            ))))
      true)
    (= (num-roots p) n))
  (
    (set (partial-factored p) (MulFactor a (+ b 1) f))
    (set (num-roots p) (+ n 1)))
  :ruleset incr-multiplicity)

; Finally, if we finished factoring a polynomial,
; equate it with its factored form
(ruleset merge-factored)
(rule
  (
    (= (factorable p) true)
    (= (num-roots p) (degree p))
    (= (partial-factored p) f))
  ((union p f) (set (factorable p) false))
  :ruleset merge-factored)

; Some example polynomials

; 10 = 10
(let p-const (Const (rational 10 1)))
(set (factorable p-const) true)

; x^2 - 1/4 = (x-1/2)(x+1/2)
(let p-rat (AddTerm (rational 1 1) 2 (Const (rational -1 4))))
(set (factorable p-rat) true)

; x^2 - 2 = (x-sqrt(2))(x+sqrt(2))
(let p-alg (AddTerm (rational 1 1) 2 (Const (rational -2 1))))
(set (factorable p-alg) true)

; x^2 + 1 = (x-i)(x+i)
(let p-complex (AddTerm (rational 1 1) 2 (Const (rational 1 1))))
(set (factorable p-complex) true)

; 3x^7 - (49x^6)/2 + (232x^5)/3 - (697x^4)/6 + (229x^3)/3 - (5x^2)/6 - (70x)/3 + 49/6
; = 3 * (x-7/3)^2 * (x-1)^4 * (x+1/2)
(let big-p-rat
  (AddTerm (rational 3 1) 7
    (AddTerm (rational -49 2) 6
      (AddTerm (rational 232 3) 5
        (AddTerm (rational -697 6) 4
          (AddTerm (rational 229 3) 3
            (AddTerm (rational -5 6) 2
              (AddTerm (rational -70 3) 1
                (Const (rational 49 6))))))))))
(set (factorable big-p-rat) true)

; Interleave egglog and SMT operation in schedule
(run-schedule (seq
    (saturate (run coeff-deg))
    (run init-roots)
    (saturate (run to-smt))
    (saturate (seq
        (saturate (run make-constraints))
        (run solve-root)
        (run update-factors)
        (saturate (seq
            (run add-deriv)
            (saturate (run differentiate))
            (saturate (run to-smt))
            (run incr-multiplicity)))
        (run merge-factored)))))

; Expect only p-rat and big-p-rat to have been rewritten.
; Strictly, p-const was also rewritten,
; but both forms are syntactically equivalent.
(extract p-const 2)
(extract p-rat 2)
(extract p-alg 2)
(extract p-complex 2)
(extract big-p-rat 2)
